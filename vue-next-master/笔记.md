## reactive相关：
    定义: 接收一个普通对象然后返回该普通对象的响应式代理
    实现:是由 proxy 加 effect 组合
    const obj = reactive({ count: 0 })
#####  解构reactive
         return ...toRefs(state)

#### reactive:绑定未响应式（深层）

#### shallowReactive:绑定未响应式（浅层-第一层）

#### readonly

###  shallowReadonly

#### 检测方法

#### 对应的检测方法有

isReactive 方法

isReadonly 方法

isProxy 方法


#### makRaw：
        显示的标记某个对象永远不会成为响应式对象
       主要是为对象增加了 ReactiveFlags.SKIP === "__v_skip"属性


#### toRaw： 
        方法将会获得你传入的原始数据,主要是通过
        ReactiveFlags.RAW === "__v_raw" 属性，这个属性在 proxy 的 handler 的get 函数中会直接返回传入的原始对象，但是其实会多一个 __v_reactive 属性(也有可能是__v_readonly)，记录响应式对象__v_reactive 和 _v_readonly 这两个属性只能有一个存在在源对象上，他们是在 proxy 处理完对象后，使用key 就是 __v_reactive 和 _v_readonly 其中之一，主要看你的响应式数据时从哪个响应式 api 中获得的
        Object.defineProperty(obj, key,{
         // vue3.0 并没有忘记他
            configurable: true,
            enumerable: false, //不可枚举
            value // proxy 后的响应式对象
            })

#### shallowReactive后的proxy的属性再次被reactive可以被观察
             const props: any = shallowReactive({ n: reactive({ foo: 1 }) })
            props.n = reactive({ foo: 2 })
            expect(isReactive(props.n)).toBe(true)


#### iterating（解构的） 不能被观察
#### 可被观察的结构方式：
##### toRefs用法：
    可以把一个对象之类的值，解构并且保持他的响应性
    const state = reactive({
        foo: 1,
        bar: 2
    })
    // 返回时转换为ref
    return ...toRefs(state)


#### get 到的某个属性不能被观察

  const shallowMap = shallowReactive(new Map())
  const a = {}
  const key = 'a'
  shallowMap.set(key, a)
  expect(isReactive(shallowMap.get(key))).toBe(false)

#### foreach 不能被观察

 const shallowSet = shallowReactive(new Set())
  const a = {}
  shallowSet.add(a)
  shallowSet.forEach(x => expect(isReactive(x)).toBe(false))


## ref
    const count = ref(0)
    console.log(count.value) // 0

    count.value++
    console.log(count.value) // 1
