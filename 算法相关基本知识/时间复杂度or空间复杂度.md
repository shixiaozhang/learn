# 算法的复杂度按最高的复杂度算；

* n^3^ + n^2^ + 1 时间复杂度为n^3^
* 2 个 n^2^ + 3 个 n + 6 个 O(1) 时间复杂度为 n^2^

# 时间复杂度

### 从小到大：

O(1)  > O(log n) > O(n) > O(n log n) > O(n^2^) 

---下面就要被优化  >  O(n^3^)   >  O(2^n^)  .....

## O(1) ：

    if(I==1);
    a=1   result=3+4  result= n*2  result= 1000*1000

    array.push('a')   array.pop()
    map.set(1,1)     map.get(1,1)

在计算复杂度的时候，O(1) 一般被忽略；

## O(n)：

for循环，while循环（不使用二分搜索）

    for(let i = 0;i < n ;i++)    let i = 0; while( i < n)
    
    let a=0;
    for(let i=0;i < n; i++){
        a+=i
    }

## O(n^2^)：

循环嵌套，嵌套while循环；

for(let i=0;i < n; i++){
    for(let j =0; j < 0; j++){
        a+=i;
    }
}

//这个时间复杂度为O(n);因为j 并不是从0开始；i和j两个是有一个继承关系；i+j=n ====》所以最后是O(n)而不是O(n^2^)
let i = 0; 
while( i < n){
    i++;j=i;
    while(j <n){
        i++
    }
}

## O(log n)：二分搜索或二分查找


## O(n log n)：排序 array.sort()


# 空间复杂度:解题过程中创建的变量、链表、等；这写方便我们解题的数据结构就怎加了一些空间复杂度；

## O(1) ：任何的单一变量

const a=1


## O(n)：我们自己定义的；而不是题目本身给定的--作为变量传进来的都不算；

* 定义一个长度为 n 的数组

* 定义一个长度为 n 的 set 、map

* 用for 循环生成一个长度为n 的链表



## O(n^2^)：
* 二维数组
* 以为数组每个元素里面放了一个长度为n的set 、map 、链表


# 空间和时间复杂度取舍：

尽量去时间复杂度小的解法；因为空间存储比较廉价


# 复杂度优化：从低一级的复杂度去寻找灵感；

O(n) - 》 O(log n) 能否使用二分搜索

O(n log n) -> O(n) 遇到排序的题，想想能否通过数组、map set hash解决

O(n^2^) -> O(n log n)  遇到循环嵌套，想想能不能通过排序+ 一个for 循环解决
 
